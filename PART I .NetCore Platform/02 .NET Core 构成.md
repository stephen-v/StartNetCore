# 详解 .NET Core 构成体系

<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [详解 .NET Core 构成体系](#详解-net-core-构成体系)
	- [Roslyn 编译器](#roslyn-编译器)
	- [Ryujit 编译器](#ryujit-编译器)
	- [CoreRT & CorlCLR](#corert-corlclr)
	- [CoreFX(.NET Core Libraries)](#corefxnet-core-libraries)
	- [.NET Core 代码开发、部署、运行过程](#net-core-代码开发部署运行过程)
	- [总结](#总结)

<!-- /TOC -->


**前文介绍了.NET Core 在整个.NET 平台所处的地位，以及与.NET Framework的关系**([原文链接](http://www.cnblogs.com/vipyoumay/p/5603928.html))，本文将详细介绍.NET Core 框架的构成和各模块主要功能，以及如何实现跨平台。

![构成体系](http://qiniu.xdpie.com/fd30f170f9bbdb9104de09b1d78b377c.png?imageView2/2/w/700)

上图描述了 .NET Core的系统构成，最上层是应用层，是开发基于UI的应用的框架集，包括了ASP.NET Core(用于创建web app)，和 UWP(用于创建Windows10 app)。

中间层是公共库(CoreFx),实现与.NET Standard Library ,囊括了常用系统级操作例如（文件、网络等）。

在CoreFx下是运行时环境，.NET Core 包含了两种运行时(CRL),CoreCRL是一种基于及时编译程序(Just in time compiler,JIT)的运行时,它使用了跨平台开源的编译器RyuJIT,而CoreRL是使用提前编译器(Ahead of time compiler,AOT)的运行时。相对于JIT编译器而言AOT编译器可以拥有更高的效率，在移动设备上也具有更好的节能性。

最后还要提到一个开源的跨平台编译器Roslyn，它有别于刚才两个编译器，JIT和AOT编译器主要用于将IL编译成本机机器码，而Roslyn是将C# 或 VB.NET 代码编译成程序中间语言(intermediate language,IL)。

## Roslyn 编译器
Roslyn编译器用于将C#或VB.NET代码编译为程序集(assembly)，它的编译过程是一个管道式的处理过程一共包含4个步骤，具体过程见下图。

![compiler pipeline](http://qiniu.xdpie.com/20762cf321e5aa5d20968e2081cb4e40.png?imageView2/2/w/700)

**A. Parser(解析)**

根据语法对源代码进行解析。

**B. declaration (声明)**

为代码生成元数据(metadata),元数据是一个数据表的集合，描述了在当前代码中定义的数据类型和成员，同时也描述了引用的类型及成员。

**C. Bind(绑定)**

将生成的IL代码与描述它的元数据绑定在一起，生成托管模块(managed module)。

**D. Emit(生成)**

将一个或多个托管模块合并生成程序集(assembly)。

## Ryujit 编译器
在程序运行中需要执行某一个方法，首先需要将已经编译好的IL转换本机的CPU指令，而这个任务就交给了Ryujit。它是新一代jit编译器，第一次实现了AMD64的架构，RyuJIT能够比JIT64更快地生成代码，以提高程序运行效率。

## CoreRT & CorlCLR
.NET Core Runtime (CoreRT) 和 .NET Core Runtime (CLR) 不同的是，CoreRT 提供了一套
.NET AOT 的机制,可以将 .NET 程序 编译成原生代码，不依赖 .NET 运行时而运行在宿主机器上。除此之外两个运行时大部分功能代码是共享的，比如GC。AOT的优化的好处带来的好处如下：

* 编译后生成一个单文件，包含所有的依赖，包括 CoreRT，无需安装Framework
* 启动时是机器码，不需要生成机器码，也不要加载JIT编译器
* 可以使用其他优化编译器，包括 LLILC ,IL to CPP
* 目前支持的是Console项目,计划支持 ASP.NET

CoreRT 有两个方式生成机器码，第一个使用是直接编译IL成机器码，默认情况下，RyuJIT 作为一个 AOT 编译器将 IL 编译成机器码，实际上这是一个很巧妙的策略，在 CoreCLR 中， RyuJIT 又变成了一个简单的 JIT 编译器。另一个方式是将 C# 代码编译成 C++ 代码，然后调用对应平台的 C++ 编译器优化编译成机器码。

** 使用 RyuJIT 编译成机器码：**

```
dotnet restore
dotnet build --native --ilcpath <repo_root>\bin
\Product\Windows_NT.x64.Debug\packaging\publish1
```

** 编译生成 C++ 代码：**

```
dotnet restore
  dotnet build --native --cpp --ilcpath <repo_root>\bin\Product\Windows_NT.x64.Debug\packaging\
  publish1 --cppcompilerflags /MTd

```

>注：这两个命名在.NET Core RC2 版本中均无法使用，按照官方说法是在当前版本中已经移除这个命令了，具体等6月27日正式版发出后才知道最后的情况

## CoreFX(.NET Core Libraries)
CoreFX主要包含数个公共库，例如  System.Collections, System.IO, System.Xml等。CoreFX是 .NET Standard Library 的实现，同样的.NET Framework 4.6也是基于.NET Standard Library的实现。它们目前都是基于.NET Standard Library1.6版本，具体见下表：

![standard](http://qiniu.xdpie.com/897d9d5723e96c5091dbc79c1e0d40a4.png?imageView2/2/w/700)

## .NET Core 代码开发、部署、运行过程
下图描述了从开发代码到最后发布上线的执行流程：

![执行流程](http://qiniu.xdpie.com/95793b5b01f398c517d574dced06b6a1.png?imageView2/2/w/700)

## 总结

本节介绍了.NET Core的构成体系，包括新增的多个编译器以及遵循.NET Standard Library的CoreFX,总体来说.NET Core较之前的.NET Framework 从性能和开发效率上都有很大的提升。

----

**参考链接**

【1】https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md

【2】https://github.com/dotnet/corefx

【3】https://github.com/dotnet/corefx/blob/master/Documentation/project-docs/glossary.md

【4】https://www.microsoft.com/net/core#windows
